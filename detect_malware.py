import sys
import os
import pandas as pd
import numpy as np
import pickle
import joblib
from feature_extraction import extract_features_from_file
from run import preprocess_data_ALL

def load_model(model_path="model/trained_model.pkl"):
    """Load the trained malware detection model"""
    try:
        model = joblib.load(model_path)
        return model
    except:
        print(f"Error: Could not load model from {model_path}")
        sys.exit(1)

        
def detect_malware(file_path, model_path="model/trained_model.pkl", threshold=0.5, original_filename=None):
    """
    Detect whether a file is likely malicious
    
    Args:
        file_path: Path to the file to analyze
        model_path: Path to the trained model
        threshold: Probability threshold for classifying as malicious
        original_filename: Original filename (used when the file_path is a temporary path)
        
    Returns:
        result dictionary with prediction and probability
    """
    # Check if file exists
    if not os.path.exists(file_path):
        return {"error": f"File not found: {file_path}"}
    
    # Extract features
    try:
        features = extract_features_from_file(file_path)
        # print(f"Extracted features: {features}")
        
        # Read column names from TRAIN.csv to ensure all columns are included
        train_cols = pd.read_csv("TRAIN.csv").columns.tolist()
        # Remove 'label' if present as it's not a feature
        if 'label' in train_cols:
            train_cols.remove('label')
        
        # Create a standardized feature dictionary with all expected columns
        standardized_features = {}
        for col in train_cols:
            if col not in features:
                # Create the feature but set it to None
                standardized_features[col] = None
            else:
                standardized_features[col] = features[col]


        # Convert features to dataframe (single row)
        features_df = pd.DataFrame([standardized_features])

        # make cols A and B to be of type float64 and C object
        features_df['A'] = features_df['A'].astype(np.float64)
        features_df['B'] = features_df['B'].astype(np.float64)
        features_df['C'] = features_df['C'].astype(object)

        # print(f"Features dataframe columns: {features_df.columns.tolist()}")
        
    except Exception as e:
        return {"error": f"Feature extraction failed: {str(e)}"}
    
    # Load model
    model = load_model(model_path)
    
    # Process features - simulating the test data preprocessing
    # Create a dummy training set with the same columns
    train = pd.read_csv("TRAIN.csv")
    train_labels = train['label']
    train_data = train.drop('label', axis=1)
    
    # Save SHA256 for later
    sha256 = features_df['sha256'] if 'sha256' in features_df.columns else None
    
    # Apply preprocessing pipeline
    try:
        
        # Run the preprocessing with a try-except for each step
        try:
            train_data, train_labels, processed_features = preprocess_data_ALL(
                train_data, 
                train_labels, 
                features_df
            )
        except Exception as e:
            print(f"Error in preprocess_data_ALL: {str(e)}")
            # Print traceback for more details
            import traceback
            traceback.print_exc()
            raise e
            
    except Exception as e:
        return {"error": f"Preprocessing failed: {str(e)}"}
    
    # Make prediction
    # print(f"Processed features: {processed_features}")

    probability = model.predict_proba(processed_features)[0, 1]
    prediction = "Malicious" if probability >= threshold else "Benign"
    
    return {
        "file": original_filename if original_filename else os.path.basename(file_path),
        "sha256": features.get("sha256", ""),
        "prediction": prediction,
        "malicious_probability": float(probability),
        "features": features
    }

def save_model(model, model_path="model/trained_model.pkl"):
    """Save the trained model for future use"""
    if not os.path.exists("model"):
        os.makedirs("model")
    joblib.dump(model, model_path)
    print(f"Model saved to {model_path}")

def train_and_save_model():
    """Train the model and save it for future use"""
    from run import run_pipeline, RandomForestClassifier
    
    # Load data
    train = pd.read_csv("TRAIN.csv")
    train_labels = train['label']
    train_data = train.drop('label', axis=1)
    
    # Create a dummy test dataset with the same structure as train_data
    # This ensures preprocessing doesn't fail due to missing test data
    dummy_test = pd.read_csv("TEST.csv", nrows=1)

    # Process training data
    train_data_processed, train_labels_processed, _ = preprocess_data_ALL(
        train_data, train_labels, dummy_test
    )
    
    # Train model
    model = RandomForestClassifier(
        n_estimators=300, 
        max_depth=None, 
        min_samples_split=10, 
        min_samples_leaf=4, 
        n_jobs=-1,
        random_state=42
    )
    model.fit(train_data_processed, train_labels_processed)
    
    # Save model
    save_model(model)
    print("Model saved successfully.")
    return model

def main():
    """Main function to run the malware detector"""
    if len(sys.argv) < 2:
        print("Usage: python detect_malware.py <file_path> [--train]")
        print("       python detect_malware.py --train")
        sys.exit(1)
        
    # Check if we should train the model
    if sys.argv[1] == "--train":
        print("Training and saving model...")
        train_and_save_model()
        print("Model training complete!")
        return
    
    file_path = sys.argv[1]
    result = detect_malware(file_path)
    
    if "error" in result:
        print(f"Error: {result['error']}")
        sys.exit(1)
        
    print("\n========== MALWARE DETECTION RESULTS ==========")
    print(f"File: {result['file']}")
    print(f"SHA256: {result['sha256']}")
    print(f"Prediction: {result['prediction']}")
    print(f"Malicious probability: {result['malicious_probability']:.2%}")
    print("================================================\n")
    
    # Optionally show detailed features
    if len(sys.argv) > 2 and sys.argv[2] == "--details":
        print("Feature details:")
        for key, value in result['features'].items():
            print(f"  {key}: {value}")

if __name__ == "__main__":
    main()